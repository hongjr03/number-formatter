name: Rust Tests & Excelize Report

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]

env:
  CARGO_TERM_COLOR: always

jobs:
  run_tests_and_report:
    name: Run Tests & Report
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        # For README update, if committing back to the repo, you might need a token
        # with write permissions, or use a dedicated action that handles this.
        # If using stefanzweifel/git-auto-commit-action, it often handles this with GITHUB_TOKEN.

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        # Assuming clippy & rustfmt are not strictly needed if other workflow handles them
        # However, cargo test might still benefit from a consistent toolchain version.

      - name: Run Excelize compatibility tests
        id: excelize_runner
        run: |
          cargo test --test excelize_tests -- --nocapture > excelize_results.json || true
          # The excelize_results.json now contains plain text, not JSON

      - name: Generate Test Results Badge and Summary
        id: badge_data_generator
        if: always()
        run: |
          BADGE_URL="https://img.shields.io/badge/Excelize%20Tests-pending-lightgrey?style=flat-square"
          echo "### Excelize Test Report" >> $GITHUB_STEP_SUMMARY
          
          if [ -f excelize_results.json ]; then
            echo "--- Contents of excelize_results.json (Workflow Log) --- " 
            cat excelize_results.json
            echo "--- End of excelize_results.json (Workflow Log) --- " 
            echo "--- Contents of excelize_results.json (GitHub Step Summary) --- " >> $GITHUB_STEP_SUMMARY
            cat excelize_results.json >> $GITHUB_STEP_SUMMARY # Add raw output to summary for easy viewing
            echo "--- End of excelize_results.json (GitHub Step Summary) --- " >> $GITHUB_STEP_SUMMARY

            # Extract values using grep and sed (or cut)
            # Ensure robust extraction even if lines are missing or format slightly varies by checking grep's success
            PASSED_LINE=$(grep '^PASSED:' excelize_results.json)
            FAILED_LINE=$(grep '^FAILED:' excelize_results.json)
            TOTAL_LINE=$(grep '^TOTAL:' excelize_results.json)

            PASSED_COUNT=0
            FAILED_COUNT=0
            TOTAL_COUNT=0
            PARSE_ERROR=false

            if [ -n "$PASSED_LINE" ]; then
              PASSED_COUNT=$(echo "$PASSED_LINE" | sed 's/PASSED://')
            else
              echo "Warning: Could not find PASSED line in excelize_results.json" >> $GITHUB_STEP_SUMMARY
              PARSE_ERROR=true
            fi
            
            if [ -n "$FAILED_LINE" ]; then
              FAILED_COUNT=$(echo "$FAILED_LINE" | sed 's/FAILED://')
            else
              echo "Warning: Could not find FAILED line in excelize_results.json" >> $GITHUB_STEP_SUMMARY
              PARSE_ERROR=true
            fi

            if [ -n "$TOTAL_LINE" ]; then
              TOTAL_COUNT=$(echo "$TOTAL_LINE" | sed 's/TOTAL://')
            else
              # If TOTAL line is missing, we can calculate it if PASSED and FAILED were found
              if ! $PARSE_ERROR; then # Only calculate if no prior parse error on P/F
                TOTAL_COUNT=$((PASSED_COUNT + FAILED_COUNT))
                echo "Info: TOTAL line missing, calculated as PASSED + FAILED." >> $GITHUB_STEP_SUMMARY
              else
                echo "Warning: Could not find TOTAL line and other lines also missing/error." >> $GITHUB_STEP_SUMMARY
                PARSE_ERROR=true
              fi
            fi
            
            # Check if counts are numeric, otherwise set error
            if ! [[ "$PASSED_COUNT" =~ ^[0-9]+$ && "$FAILED_COUNT" =~ ^[0-9]+$ && "$TOTAL_COUNT" =~ ^[0-9]+$ ]]; then
                echo "Error: Extracted counts are not all numeric." >> $GITHUB_STEP_SUMMARY
                echo "Passed: [$PASSED_COUNT], Failed: [$FAILED_COUNT], Total: [$TOTAL_COUNT]" >> $GITHUB_STEP_SUMMARY
                PARSE_ERROR=true
            fi 

            if $PARSE_ERROR; then
              echo "Error parsing test results from excelize_results.json." >> $GITHUB_STEP_SUMMARY
              BADGE_URL="https://img.shields.io/badge/Excelize%20Tests-data%20error-lightgrey?style=flat-square"
              echo "![Error Badge]($BADGE_URL)" >> $GITHUB_STEP_SUMMARY
            else
              echo "- Passed: $PASSED_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "- Failed: $FAILED_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "- Total: $TOTAL_COUNT" >> $GITHUB_STEP_SUMMARY
              
              LABEL="Excelize Tests: $PASSED_COUNT passed / $TOTAL_COUNT total"
              COLOR="brightgreen"
              if [ "$FAILED_COUNT" -ne 0 ]; then # Use -ne for numeric comparison
                LABEL="Excelize Tests: $PASSED_COUNT passed, $FAILED_COUNT failed / $TOTAL_COUNT total"
                COLOR="red"
              fi
              ENCODED_LABEL=$(echo "$LABEL" | sed -e 's/ /%20/g' -e 's/:/%3A/g' -e 's/\//%2F/g' -e 's/-/%2D%2D/g')
              BADGE_URL="https://img.shields.io/badge/$ENCODED_LABEL-$COLOR?style=flat-square"
              echo "Badge URL: $BADGE_URL" 
              echo "![Excelize Tests Badge]($BADGE_URL)" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "excelize_results.json not found. Excelize tests might have failed to produce output." >> $GITHUB_STEP_SUMMARY
            BADGE_URL="https://img.shields.io/badge/Excelize%20Tests-no%20data-lightgrey?style=flat-square"
            echo "![No Data Badge]($BADGE_URL)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "badge_url=$BADGE_URL" >> $GITHUB_OUTPUT

      - name: Upload Excelize Results Artifact on Failure or Always
        if: always() # Use always() to upload regardless of success/failure, or failure() to upload only on job failure
        uses: actions/upload-artifact@v4 # Updated to v4
        with:
          name: excelize-test-results # Name of the artifact bundle
          path: excelize_results.json # Path to the file to upload
          retention-days: 7 # Optional: How long to keep the artifact (default is 90)
          if-no-files-found: warn # Optional: What to do if excelize_results.json is not found

      - name: Update README with Badge
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' && always()
        env:
          BADGE_URL: ${{ steps.badge_data_generator.outputs.badge_url }}
        run: |
          if [ -z "$BADGE_URL" ]; then
            echo "Badge URL is empty, skipping README update."
            exit 0
          fi
          echo "Updating README with badge URL: $BADGE_URL"
          MARKDOWN_BADGE="![Excelize Tests Badge]($BADGE_URL)"
          PLACEHOLDER="<!-- EXCELIZE_TEST_BADGE -->"
          README_FILE="README.md"
          
          # Create README.md if it doesn't exist and add placeholder
          if [ ! -f "$README_FILE" ]; then
            echo "$PLACEHOLDER" > "$README_FILE"
            echo "Created README.md with placeholder."
          fi

          # Check if placeholder exists
          if grep -q "$PLACEHOLDER" "$README_FILE"; then
            # Escape for sed: & / \ need to be escaped
            # Also escape characters that might be in the badge URL and break sed: e.g., -
            ESC_MARKDOWN_BADGE=$(echo "$MARKDOWN_BADGE" | sed 's/[&\/]/\\&/g; s/-/\\-/g') 
            # Using a different delimiter for sed to handle slashes in URL
            sed -i "s~$PLACEHOLDER~$ESC_MARKDOWN_BADGE~g" "$README_FILE"
            echo "README.md updated."
          else
            echo "Placeholder $PLACEHOLDER not found in $README_FILE. Badge not updated."
            echo "Please add \"$PLACEHOLDER\" to your $README_FILE where you want the badge."
            # Optionally, append if not found?
            # echo "$MARKDOWN_BADGE" >> "$README_FILE"
            # echo "Badge appended to $README_FILE as placeholder was not found."
          fi

      - name: Commit and push README changes
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' && always()
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ci: Update Excelize tests badge in README"
          file_pattern: README.md
          # Optional: Add other options like commit_user_name, commit_user_email, commit_author if needed
          # See action documentation for more details: https://github.com/stefanzweifel/git-auto-commit-action

    # If you need the raw JSON as an output for another job in this workflow:
    # outputs:
    #   excelize_test_json: ${{
    #     steps.excelize_runner.outputs.json_content || '{ "passed": 0, "failed": 0, "total": 0 }'
    #   }}
    # To use this output, the excelize_runner step would need to set an output like:
    # echo "json_content=$(cat excelize_results.json)" >> $GITHUB_OUTPUT